
Currently the renderers shader library can be populated with sahders. All mesh classes will have a function that returns their type
and the renderer would bind the appropriate shader based on this type then call the draw function of the mesh (which would populate the uniforms in the shader).->
-> There is a little problem here, the mesh would need to upload the uniforms, but for that it would need a pointer or reference to the bound shader. I can make
a draw function that takes a shader parameter and in the meshes draw call use it to upload the uniforms, but this solution feels like it would entangle parts
of the code that shouldnt be entangled.

This function can query the currently bound texture (https://gamedev.stackexchange.com/questions/79075/how-to-obtain-the-currently-bound-texture-id-in-an-opengl-es-2-0-project):
GLint whichID;
glGetIntegerv(GL_TEXTURE_BINDING_2D, &whichID);

And this one do the same for shader (https://community.khronos.org/t/how-do-i-get-restore-the-current-shader/67005)
GLint id;
glGetIntegerv(GL_CURRENT_PROGRAM,&id);

This feels somewhat fragile, because populating the shader library and binding shaders based on mesh type needs to be consistent, which could break.
I dont know how well this is going to work, maybe with sufficiently low number of shaders and mesh types this is okay, or maybe with a few simple checks
the inconsistencies can be revealed more easily. I will see...



Or... Perhaps I should set up the ECS first. Then the entities would have a draw function. The draw function would bind or just select the shader from the library based on the
entities material. In this case it would already have access to the appropriate shader, so uploading other uniforms based on other components of the entiyt might be easier.


Next things to do (as of 2021.11.14.):
- scene serialization: This is not going to be that easy. After the scene is created, it should be rendered somehow. The camera should be separated from the
	rest of the entities, since it shouldnt be drawn, but its location and orientation has to be set before any other object is rendered. Maybe I could create
	a separate component just for the camera...
	For the rest, I could retrieve all entities that have transform and mesh components (or rather retrive the trf+mesh component pairs - with EnTT's group 
	function), since only these two are used for rendering.

- Very important resource saving concept:
	https://learnopengl.com/Advanced-OpenGL/Instancing
	https://www.khronos.org/opengl/wiki/Vertex_Rendering#Instancing
	https://www.youtube.com/watch?v=9F_lUPPS_pg
	
- Change all meshes to the instance rendered versions. Rendering one entity could be just an instance rendered draw
	with one transform component.
	Shadow mapping should also switch to the instance rendered version.



Before the missing features, some organizational work should be done.
Core and game specific code should be separated. Under this I mean
the components should be separated to core and game components. The 
scene serialization and update should also go to the game side, as
the components can be client specific.


Missing featuers:
- mouse picking (core feature) -> this needs a lot of change on the rendering,
	the entity id should be added to the instances and rendered into a separate
	framebuffer (or at least an additional colour attachment), and I dont feel
	like this feature would be that useful at the moment, so probably I wont implement this
The rest is definitely game side:
- Composite meshes (like a ship with a normal mesh plus a bright mesh as the engine, probably core side)
- AI behaviours (probably game side),
- Sounds (it might be enough to implement it on the game side),
- entity bound camera (probably game side),


Mostly done (could take some tweaking):
- bloom effect,
- collisions: went to the utilities and the game's side. Currently this works by a dual oct tree,
	it has two oct trees, one is being used for querying object from a spatial interval, meanwhile
	the other is being built on a separate CPU thread. The building process takes ~500-1000 micro
	seconds depending on the asteroid count. Unfortunately I have seen the program crash in debug
	mode, probably because the oct tree building takes longer than 1 game cycle and the state of
	the asteroid pool changes and the iterator used in the building thread becomes invalid. So this
	problem doesnt come up when the build is quick, but could potentially cause failures. This
	will definitely require some attention. Perhaps even the building could be done on the main
	thread, if it's only half to one milli sec, it might be still okay.

Features done:
- Markers (create a new mesh type for them, core feature),
- moving objects,
- shooting,
- text rendering: done, but havent used the saved tutorial link. I created a new MeshType - LETTER_MESH
	and put the drawing parameters into the TransformComponent instance array.


Other things to implement:
- Add mip-map to the textures -> done in the mesh constructors
- generalize the framebuffer class to be able to hold arbitrary number of colour attachments
	(so I dont need 3 classes for almost the same things: shadow/doubleFB/single FB) -> this is done
- Create a ColliderComponent and build the OctTree and check collisions based on that. -> mostly done
	a few issues came up with this, namely that the ships firing torpedoes are being hit by their own
	torpedoes.
- Create a secondary mesh library for static meshes, which are not being updated every frame, only at
		rare occasions.


Test lower OpenGL versions! -> did it, but none of those versions were running on Niki's laptop.

Blender: proper sphere texturing


Game ideas:
Asteroids coming, the player controls a small mobile ship that spots asteroids, while the slow long range
missille armed ships launch their missilles on the provided targets.

A cargo ship heading towards the belt has broken down (engine malfunction or somethin) and is drifting
towards the asteroid field. We as a light recon wechicle deployed from this ship, need to go ahead
and mark the dangerous asteroids for destruction, so faraway missille ships can destroy them.

Another game could be a 3D version of Agar.io, we control a sphere and have to eat smaller spheres.

Building the octTree: my idea is that there will be two octTrees, one is actively being used and another
one is being built on another thread. There should be a variable which indicates if this thread is running
or not. When the tree building starts it is set to true, when finished set to false. From outside the
building thread this variable can be checked, and if it indicates that the building has completed,
the two oct trees can be swapped and the building procedure can be started again on the back buffer.






