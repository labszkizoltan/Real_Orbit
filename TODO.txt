
Currently the renderers shader library can be populated with sahders. All mesh classes will have a function that returns their type
and the renderer would bind the appropriate shader based on this type then call the draw function of the mesh (which would populate the uniforms in the shader).->
-> There is a little problem here, the mesh would need to upload the uniforms, but for that it would need a pointer or reference to the bound shader. I can make
a draw function that takes a shader parameter and in the meshes draw call use it to upload the uniforms, but this solution feels like it would entangle parts
of the code that shouldnt be entangled.

This function can query the currently bound texture (https://gamedev.stackexchange.com/questions/79075/how-to-obtain-the-currently-bound-texture-id-in-an-opengl-es-2-0-project):
GLint whichID;
glGetIntegerv(GL_TEXTURE_BINDING_2D, &whichID);

And this one do the same for shader (https://community.khronos.org/t/how-do-i-get-restore-the-current-shader/67005)
GLint id;
glGetIntegerv(GL_CURRENT_PROGRAM,&id);

This feels somewhat fragile, because populating the shader library and binding shaders based on mesh type needs to be consistent, which could break.
I dont know how well this is going to work, maybe with sufficiently low number of shaders and mesh types this is okay, or maybe with a few simple checks
the inconsistencies can be revealed more easily. I will see...



Or... Perhaps I should set up the ECS first. Then the entities would have a draw function. The draw function would bind or just select the shader from the library based on the
entities material. In this case it would already have access to the appropriate shader, so uploading other uniforms based on other components of the entiyt might be easier.


Next things to do (as of 2021.11.14.):
- scene serialization: This is not going to be that easy. After the scene is created, it should be rendered somehow. The camera should be separated from the
	rest of the entities, since it shouldnt be drawn, but its location and orientation has to be set before any other object is rendered. Maybe I could create
	a separate component just for the camera...
	For the rest, I could retrieve all entities that have transform and mesh components (or rather retrive the trf+mesh component pairs - with EnTT's group 
	function), since only these two are used for rendering.

- Very important resource saving concept:
	https://learnopengl.com/Advanced-OpenGL/Instancing
	https://www.khronos.org/opengl/wiki/Vertex_Rendering#Instancing
	https://www.youtube.com/watch?v=9F_lUPPS_pg
	
- Change all meshes to the instance rendered versions. Rendering one entity could be just an instance rendered draw
	with one transform component.
	Shadow mapping should also switch to the instance rendered version.



Before the missing features, some organizational work should be done.
Core and game specific code should be separated. Under this I mean
the components should be separated to core and game components. The 
scene serialization and update should also go to the game side, as
the components can be client specific.


Missing featuers:
- mouse picking (core feature) -> this needs a lot of change on the rendering,
	the entity id should be added to the instances and rendered into a separate
	framebuffer (or at least an additional colour attachment), and I dont feel
	like this feature would be that useful at the moment, so probably I wont implement this
The rest is definitely game side:
- Composite meshes (like a ship with a normal mesh plus a bright mesh as the engine, probably core side)
- AI behaviours (probably game side),
- collisions (probably game side),
- Sounds (it might be enough to implement it on the game side),
- entity bound camera (probably game side),


Mostly done (could take some tweaking):
- bloom effect,

Features done:
- Markers (create a new mesh type for them, core feature),
- moving objects,
- shooting,


Other things to implement:
- Add mip-map to the textures -> done in the mesh constructors
- generalize the framebuffer class to be able to hold arbitrary number of colour attachments
	(so I dont need 3 classes for almost the same things: shadow/doubleFB/single FB) -> this is done

Test lower OpenGL versions! -> did it, but none of those versions were running on Niki's laptop.

Blender: proper sphere texturing


Game ideas:
Asteroids coming, the player controls a small mobile ship that spots asteroids, while the slow long range
missille armed ships launch their missilles on the provided targets.










